---
title: "Ruby Examples"
description: "Complete Ruby examples for working with the ZipKit API"
---

## Overview

These examples show how to use ZipKit with Ruby using the built-in `net/http` library and the popular `httparty` gem. Perfect for Ruby on Rails applications, scripts, and automation.

## Prerequisites

- Ruby 2.7 or higher
- A ZipKit account with an access token
- A configured bucket

## Using Net::HTTP (Built-in)

### Basic Example: Create a ZIP

```ruby
require 'net/http'
require 'json'
require 'uri'

ACCESS_TOKEN = 'your-access-token'
API_URL = 'https://zipkit.io/api/v1'

def create_zip(urls, bucket_name, key = nil)
  uri = URI("#{API_URL}/zips")
  http = Net::HTTP.new(uri.host, uri.port)
  http.use_ssl = true

  request = Net::HTTP::Post.new(uri.path, {
    'Authorization' => "Bearer #{ACCESS_TOKEN}",
    'Content-Type' => 'application/json'
  })

  body = {
    urls: urls,
    bucket_name: bucket_name
  }
  body[:key] = key if key

  request.body = body.to_json

  response = http.request(request)

  if response.is_a?(Net::HTTPSuccess)
    data = JSON.parse(response.body)
    zip_data = data['data']
    puts "ZIP created with ID: #{zip_data['id']}"
    puts "Initial status: #{zip_data['status']}"
    zip_data
  else
    puts "Error: #{response.code} #{response.message}"
    puts response.body
    nil
  end
end

# Usage
zip = create_zip(
  ['https://example.com/file1.pdf', 'https://example.com/file2.jpg'],
  'my-destination-bucket',
  'archives/quarterly-report.zip'
)
```

### Check ZIP Status

```ruby
def get_zip_status(zip_id)
  uri = URI("#{API_URL}/zips/#{zip_id}")
  http = Net::HTTP.new(uri.host, uri.port)
  http.use_ssl = true

  request = Net::HTTP::Get.new(uri.path, {
    'Authorization' => "Bearer #{ACCESS_TOKEN}"
  })

  response = http.request(request)

  if response.is_a?(Net::HTTPSuccess)
    data = JSON.parse(response.body)
    zip_data = data['data']
    puts "ZIP status: #{zip_data['status']}"
    zip_data
  else
    puts "Error: #{response.code} #{response.message}"
    nil
  end
end

# Usage
zip_data = get_zip_status('clx7g2m4p0000xyz123abc')
```

### Complete ZipKit Client Class

```ruby
require 'net/http'
require 'json'
require 'uri'

class ZipKitClient
  attr_reader :access_token, :api_url

  def initialize(access_token)
    @access_token = access_token
    @api_url = 'https://zipkit.io/api/v1'
  end

  def create_zip(urls:, bucket_name:, key: nil, service: 's3')
    uri = URI("#{@api_url}/zips")
    http = Net::HTTP.new(uri.host, uri.port)
    http.use_ssl = true

    request = Net::HTTP::Post.new(uri.path, {
      'Authorization' => "Bearer #{@access_token}",
      'Content-Type' => 'application/json'
    })

    body = {
      urls: urls,
      bucket_name: bucket_name,
      service: service
    }
    body[:key] = key if key

    request.body = body.to_json

    response = http.request(request)
    handle_response(response)
  end

  def get_zip_status(zip_id)
    uri = URI("#{@api_url}/zips/#{zip_id}")
    http = Net::HTTP.new(uri.host, uri.port)
    http.use_ssl = true

    request = Net::HTTP::Get.new(uri.path, {
      'Authorization' => "Bearer #{@access_token}"
    })

    response = http.request(request)
    handle_response(response)
  end

  def wait_for_zip(zip_id, max_attempts: 30, delay: 2)
    max_attempts.times do |attempt|
      zip_data = get_zip_status(zip_id)
      status = zip_data['status']

      puts "Attempt #{attempt + 1}/#{max_attempts}: Status is '#{status}'"

      case status
      when 'succeeded'
        return zip_data
      when 'failed'
        raise "ZIP creation failed for ID: #{zip_id}"
      end

      sleep(delay)
    end

    raise "ZIP did not complete within #{max_attempts} attempts"
  end

  private

  def handle_response(response)
    if response.is_a?(Net::HTTPSuccess)
      data = JSON.parse(response.body)
      data['data']
    else
      error_data = JSON.parse(response.body) rescue {}
      error_msg = error_data['message'] || response.message
      raise "HTTP #{response.code}: #{error_msg}"
    end
  end
end

# Usage
client = ZipKitClient.new('your-access-token')

begin
  # Create ZIP
  puts 'Creating ZIP...'
  zip = client.create_zip(
    urls: [
      'https://example.com/file1.pdf',
      'https://example.com/file2.jpg'
    ],
    bucket_name: 'my-destination-bucket',
    key: 'my-archive.zip'
  )

  puts "ZIP ID: #{zip['id']}"

  # Wait for completion
  completed_zip = client.wait_for_zip(zip['id'])
  puts '✓ ZIP created successfully!'
  puts '  Location: my-destination-bucket/my-archive.zip'

rescue => e
  puts "✗ Error: #{e.message}"
end
```

## Using HTTParty Gem

Install HTTParty:

```bash
gem install httparty
```

### HTTParty Client Class

```ruby
require 'httparty'

class ZipKitClient
  include HTTParty
  base_uri 'https://zipkit.io/api/v1'

  def initialize(access_token)
    @auth_header = { 'Authorization' => "Bearer #{access_token}" }
  end

  def create_zip(urls:, bucket_name:, key: nil, service: 's3')
    body = {
      urls: urls,
      bucket_name: bucket_name,
      service: service
    }
    body[:key] = key if key

    response = self.class.post('/zips',
      headers: @auth_header.merge({ 'Content-Type' => 'application/json' }),
      body: body.to_json
    )

    handle_response(response)
  end

  def get_zip_status(zip_id)
    response = self.class.get("/zips/#{zip_id}",
      headers: @auth_header
    )

    handle_response(response)
  end

  def wait_for_zip(zip_id, max_attempts: 30, delay: 2)
    max_attempts.times do |attempt|
      zip_data = get_zip_status(zip_id)
      status = zip_data['status']

      puts "Attempt #{attempt + 1}: #{status}"

      return zip_data if status == 'succeeded'
      raise "ZIP failed: #{zip_id}" if status == 'failed'

      sleep(delay)
    end

    raise "Timeout waiting for ZIP: #{zip_id}"
  end

  private

  def handle_response(response)
    if response.success?
      response.parsed_response['data']
    else
      error_msg = response.parsed_response['message'] || response.message
      raise "HTTP #{response.code}: #{error_msg}"
    end
  end
end

# Usage
client = ZipKitClient.new(ENV['ZIPKIT_TOKEN'])

zip = client.create_zip(
  urls: ['https://example.com/file.pdf'],
  bucket_name: 'my-bucket',
  key: 'archive.zip'
)

completed = client.wait_for_zip(zip['id'])
puts "ZIP complete: #{completed}"
```

## Rails Integration

### config/initializers/zipkit.rb

```ruby
require 'zipkit_client'

Rails.configuration.zipkit = ZipKitClient.new(
  ENV['ZIPKIT_ACCESS_TOKEN']
)
```

### app/services/zip_creator_service.rb

```ruby
class ZipCreatorService
  def initialize(files, user)
    @files = files
    @user = user
  end

  def create
    # Upload files to S3 first (or use existing S3 URLs)
    urls = @files.map { |file| upload_to_s3(file) }

    # Create ZIP via ZipKit
    zip = Rails.configuration.zipkit.create_zip(
      urls: urls,
      bucket_name: ENV['ZIPKIT_BUCKET_NAME'],
      key: "users/#{@user.id}/archive_#{Time.now.to_i}.zip"
    )

    # Store ZIP job in database
    ZipJob.create!(
      user: @user,
      zipkit_id: zip['id'],
      status: zip['status'],
      urls: urls
    )

    zip
  rescue => e
    Rails.logger.error("Failed to create ZIP: #{e.message}")
    raise
  end

  private

  def upload_to_s3(file)
    # Your S3 upload logic here
    # Returns the S3 URL
  end
end
```

### app/controllers/webhooks/zipkit_controller.rb

```ruby
module Webhooks
  class ZipkitController < ApplicationController
    skip_before_action :verify_authenticity_token
    before_action :verify_webhook_secret

    def create
      payload = params.permit!.to_h

      zip_id = payload['zip_id']
      status = payload['status']

      # Find the ZIP job
      zip_job = ZipJob.find_by(zipkit_id: zip_id)

      if zip_job.nil?
        Rails.logger.warn("Received webhook for unknown ZIP: #{zip_id}")
        return head :not_found
      end

      # Update status
      zip_job.update!(
        status: status,
        completed_at: Time.current
      )

      if status == 'succeeded'
        # Notify user
        ZipCompletedMailer.notify(zip_job).deliver_later

        # Store metadata
        zip_job.update!(
          bucket_name: payload.dig('bucket', 'name'),
          key: payload['key'],
          checksum: payload['checksum']
        )

        Rails.logger.info("ZIP #{zip_id} completed successfully")
      else
        Rails.logger.error("ZIP #{zip_id} failed")
      end

      head :ok
    end

    private

    def verify_webhook_secret
      expected = "Bearer #{ENV['ZIPKIT_WEBHOOK_SECRET']}"
      actual = request.headers['Authorization']

      unless ActiveSupport::SecurityUtils.secure_compare(expected, actual)
        head :unauthorized
      end
    end
  end
end
```

### config/routes.rb

```ruby
Rails.application.routes.draw do
  namespace :webhooks do
    post 'zipkit', to: 'zipkit#create'
  end
end
```

## Sinatra Webhook Handler

```ruby
require 'sinatra'
require 'json'

# Your webhook secret
WEBHOOK_SECRET = ENV['ZIPKIT_WEBHOOK_SECRET']

post '/webhooks/zipkit' do
  # Verify authorization
  auth_header = request.env['HTTP_AUTHORIZATION']

  unless auth_header == "Bearer #{WEBHOOK_SECRET}"
    halt 401, { error: 'Unauthorized' }.to_json
  end

  # Parse payload
  payload = JSON.parse(request.body.read)

  zip_id = payload['zip_id']
  status = payload['status']

  if status == 'succeeded'
    bucket = payload['bucket']['name']
    key = payload['key']
    checksum = payload['checksum']

    puts "✓ ZIP #{zip_id} succeeded"
    puts "  Location: #{bucket}/#{key}"
    puts "  Checksum: #{checksum}"

    # Process the ZIP
    # process_zip(bucket, key)

  elsif status == 'failed'
    puts "✗ ZIP #{zip_id} failed"

    # Handle failure
    # handle_failed_zip(zip_id)
  end

  content_type :json
  { received: true }.to_json
end
```

## Error Handling

```ruby
def create_zip_with_error_handling(urls, bucket_name)
  client = ZipKitClient.new(ENV['ZIPKIT_TOKEN'])

  begin
    zip = client.create_zip(
      urls: urls,
      bucket_name: bucket_name
    )

    puts "Success: ZIP ID #{zip['id']}"
    zip

  rescue => e
    case e.message
    when /401/
      puts 'Error: Invalid access token'
    when /404/
      puts 'Error: Bucket not found'
    when /400/
      puts "Error: Bad request - #{e.message}"
    else
      puts "Error: #{e.message}"
    end

    nil
  end
end

# Usage
result = create_zip_with_error_handling(
  ['https://example.com/file.pdf'],
  'my-bucket'
)
```

## Using Environment Variables

```ruby
# Load from .env file
require 'dotenv/load'

ACCESS_TOKEN = ENV['ZIPKIT_ACCESS_TOKEN']
BUCKET_NAME = ENV['ZIPKIT_BUCKET_NAME']

raise 'ZIPKIT_ACCESS_TOKEN not set' unless ACCESS_TOKEN

client = ZipKitClient.new(ACCESS_TOKEN)

zip = client.create_zip(
  urls: ['https://example.com/file.pdf'],
  bucket_name: BUCKET_NAME || 'default-bucket',
  key: 'archive.zip'
)
```

Create a `.env` file:

```
ZIPKIT_ACCESS_TOKEN=your-access-token
ZIPKIT_BUCKET_NAME=my-bucket
```

## Batch Processing

```ruby
class ZipKitBatchProcessor
  def initialize(access_token)
    @client = ZipKitClient.new(access_token)
  end

  def create_multiple_zips(zip_configs)
    require 'concurrent'

    # Process ZIPs concurrently
    pool = Concurrent::FixedThreadPool.new(5)
    promises = []

    zip_configs.each do |config|
      promise = Concurrent::Promise.execute(executor: pool) do
        @client.create_zip(
          urls: config[:urls],
          bucket_name: config[:bucket_name],
          key: config[:key]
        )
      end

      promises << promise
    end

    # Wait for all to complete
    results = promises.map(&:value)

    pool.shutdown
    pool.wait_for_termination

    results.compact
  end
end

# Usage
processor = ZipKitBatchProcessor.new('your-access-token')

configs = [
  {
    urls: ['https://example.com/file1.pdf'],
    bucket_name: 'my-bucket',
    key: 'archive1.zip'
  },
  {
    urls: ['https://example.com/file2.pdf'],
    bucket_name: 'my-bucket',
    key: 'archive2.zip'
  },
  {
    urls: ['https://example.com/file3.pdf'],
    bucket_name: 'my-bucket',
    key: 'archive3.zip'
  }
]

zips = processor.create_multiple_zips(configs)
puts "Created #{zips.length} ZIPs"
```

## Next Steps

<CardGroup cols={2}>
  <Card title="Python Examples" icon="python" href="/code-examples/python">
    See examples using Python's requests library
  </Card>

  <Card title="JavaScript Examples" icon="js" href="/code-examples/javascript">
    See examples using Node.js and fetch
  </Card>

  <Card title="cURL Examples" icon="terminal" href="/code-examples/curl">
    See examples using cURL
  </Card>

  <Card title="API Reference" icon="book" href="/api-reference/create-zip">
    View complete API documentation
  </Card>
</CardGroup>
