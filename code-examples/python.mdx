---
title: "Python Examples"
description: "Complete Python examples for working with the ZipKit API"
---

## Overview

These examples show how to use ZipKit with Python using the popular `requests` library. Perfect for automation, data processing, and integrating ZipKit into your Python applications.

## Prerequisites

- Python 3.7 or higher
- `requests` library: `pip install requests`
- A ZipKit account with an access token
- A configured bucket

## Installation

```bash
pip install requests
```

## Basic Example: Create a ZIP

```python
import requests

# Your ZipKit access token
ACCESS_TOKEN = "your-access-token"
API_URL = "https://zipkit.io/api/v1"

# Create headers
headers = {
    "Authorization": f"Bearer {ACCESS_TOKEN}",
    "Content-Type": "application/json"
}

# Create a ZIP
data = {
    "urls": [
        "https://my-bucket.s3.amazonaws.com/report.pdf",
        "https://my-bucket.s3.amazonaws.com/data.csv"
    ],
    "bucket_name": "my-destination-bucket",
    "key": "archives/quarterly-report.zip"
}

response = requests.post(f"{API_URL}/zips", json=data, headers=headers)
response.raise_for_status()  # Raise exception for 4xx/5xx responses

zip_data = response.json()
zip_id = zip_data['data']['id']
status = zip_data['data']['status']

print(f"ZIP created with ID: {zip_id}")
print(f"Initial status: {status}")
```

## Check ZIP Status

```python
import requests

ACCESS_TOKEN = "your-access-token"
API_URL = "https://zipkit.io/api/v1"
zip_id = "clx7g2m4p0000xyz123abc"

headers = {
    "Authorization": f"Bearer {ACCESS_TOKEN}"
}

response = requests.get(f"{API_URL}/zips/{zip_id}", headers=headers)
response.raise_for_status()

zip_data = response.json()
status = zip_data['data']['status']

print(f"ZIP status: {status}")
```

## Complete Workflow with Polling

```python
import requests
import time

class ZipKitClient:
    def __init__(self, access_token):
        self.access_token = access_token
        self.api_url = "https://zipkit.io/api/v1"
        self.headers = {
            "Authorization": f"Bearer {access_token}",
            "Content-Type": "application/json"
        }

    def create_zip(self, urls, bucket_name, key=None, service="s3"):
        """Create a new ZIP archive."""
        data = {
            "urls": urls,
            "bucket_name": bucket_name,
            "service": service
        }
        if key:
            data["key"] = key

        response = requests.post(
            f"{self.api_url}/zips",
            json=data,
            headers=self.headers
        )
        response.raise_for_status()
        return response.json()['data']

    def get_zip_status(self, zip_id):
        """Get the status of a ZIP job."""
        response = requests.get(
            f"{self.api_url}/zips/{zip_id}",
            headers=self.headers
        )
        response.raise_for_status()
        return response.json()['data']

    def wait_for_zip(self, zip_id, max_attempts=30, delay=2):
        """
        Poll until ZIP is complete.

        Args:
            zip_id: The ZIP identifier
            max_attempts: Maximum number of polling attempts
            delay: Seconds to wait between attempts

        Returns:
            Final status data

        Raises:
            TimeoutError: If ZIP doesn't complete within max_attempts
            RuntimeError: If ZIP fails
        """
        for attempt in range(max_attempts):
            status_data = self.get_zip_status(zip_id)
            status = status_data['status']

            print(f"Attempt {attempt + 1}/{max_attempts}: Status is '{status}'")

            if status == 'succeeded':
                return status_data
            elif status == 'failed':
                raise RuntimeError(f"ZIP creation failed for ID: {zip_id}")

            time.sleep(delay)

        raise TimeoutError(f"ZIP did not complete within {max_attempts} attempts")

# Usage
if __name__ == "__main__":
    client = ZipKitClient("your-access-token")

    # Create a ZIP
    print("Creating ZIP...")
    zip_data = client.create_zip(
        urls=[
            "https://example.com/file1.pdf",
            "https://example.com/file2.jpg"
        ],
        bucket_name="my-destination-bucket",
        key="my-archive.zip"
    )

    zip_id = zip_data['id']
    print(f"ZIP ID: {zip_id}")

    # Wait for completion
    try:
        final_data = client.wait_for_zip(zip_id)
        print(f"✓ ZIP created successfully!")
        print(f"  Location: my-destination-bucket/my-archive.zip")
    except RuntimeError as e:
        print(f"✗ Error: {e}")
    except TimeoutError as e:
        print(f"⚠ Warning: {e}")
```

## Async/Await Example (with aiohttp)

For high-performance applications using async/await:

```python
import asyncio
import aiohttp

class AsyncZipKitClient:
    def __init__(self, access_token):
        self.access_token = access_token
        self.api_url = "https://zipkit.io/api/v1"
        self.headers = {
            "Authorization": f"Bearer {access_token}",
            "Content-Type": "application/json"
        }

    async def create_zip(self, session, urls, bucket_name, key=None):
        """Create a new ZIP archive asynchronously."""
        data = {
            "urls": urls,
            "bucket_name": bucket_name
        }
        if key:
            data["key"] = key

        async with session.post(
            f"{self.api_url}/zips",
            json=data,
            headers=self.headers
        ) as response:
            response.raise_for_status()
            result = await response.json()
            return result['data']

    async def get_zip_status(self, session, zip_id):
        """Get ZIP status asynchronously."""
        async with session.get(
            f"{self.api_url}/zips/{zip_id}",
            headers=self.headers
        ) as response:
            response.raise_for_status()
            result = await response.json()
            return result['data']

    async def wait_for_zip(self, session, zip_id, max_attempts=30, delay=2):
        """Wait for ZIP completion asynchronously."""
        for attempt in range(max_attempts):
            status_data = await self.get_zip_status(session, zip_id)
            status = status_data['status']

            print(f"Attempt {attempt + 1}: {status}")

            if status == 'succeeded':
                return status_data
            elif status == 'failed':
                raise RuntimeError(f"ZIP failed: {zip_id}")

            await asyncio.sleep(delay)

        raise TimeoutError(f"ZIP timed out: {zip_id}")

async def main():
    client = AsyncZipKitClient("your-access-token")

    async with aiohttp.ClientSession() as session:
        # Create ZIP
        zip_data = await client.create_zip(
            session,
            urls=["https://example.com/file1.pdf"],
            bucket_name="my-bucket",
            key="archive.zip"
        )

        # Wait for completion
        result = await client.wait_for_zip(session, zip_data['id'])
        print(f"ZIP complete: {result}")

# Run
asyncio.run(main())
```

## Using with Cloudflare R2

```python
import requests

ACCESS_TOKEN = "your-access-token"
API_URL = "https://zipkit.io/api/v1"

headers = {
    "Authorization": f"Bearer {ACCESS_TOKEN}",
    "Content-Type": "application/json"
}

# Specify service as "r2"
data = {
    "urls": [
        "https://example.com/file1.pdf",
        "https://example.com/file2.jpg"
    ],
    "bucket_name": "my-r2-bucket",
    "service": "r2",
    "key": "archives/my-archive.zip"
}

response = requests.post(f"{API_URL}/zips", json=data, headers=headers)
response.raise_for_status()

print("ZIP created:", response.json())
```

## Error Handling

```python
import requests
from requests.exceptions import HTTPError, ConnectionError, Timeout

def create_zip_safe(urls, bucket_name):
    """Create ZIP with comprehensive error handling."""
    ACCESS_TOKEN = "your-access-token"
    API_URL = "https://zipkit.io/api/v1"

    headers = {
        "Authorization": f"Bearer {ACCESS_TOKEN}",
        "Content-Type": "application/json"
    }

    data = {
        "urls": urls,
        "bucket_name": bucket_name
    }

    try:
        response = requests.post(
            f"{API_URL}/zips",
            json=data,
            headers=headers,
            timeout=10  # 10 second timeout
        )

        # Check for HTTP errors
        response.raise_for_status()

        # Success!
        result = response.json()
        return result['data']

    except HTTPError as e:
        if e.response.status_code == 401:
            print("Error: Invalid access token")
        elif e.response.status_code == 404:
            print("Error: Bucket not found")
        elif e.response.status_code == 400:
            print(f"Error: Bad request - {e.response.json()}")
        else:
            print(f"HTTP Error: {e}")
        return None

    except ConnectionError:
        print("Error: Could not connect to ZipKit API")
        return None

    except Timeout:
        print("Error: Request timed out")
        return None

    except Exception as e:
        print(f"Unexpected error: {e}")
        return None

# Usage
result = create_zip_safe(
    urls=["https://example.com/file.pdf"],
    bucket_name="my-bucket"
)

if result:
    print(f"Success! ZIP ID: {result['id']}")
else:
    print("Failed to create ZIP")
```

## Environment Variables for Configuration

```python
import os
import requests

# Store sensitive data in environment variables
ACCESS_TOKEN = os.getenv("ZIPKIT_ACCESS_TOKEN")
BUCKET_NAME = os.getenv("ZIPKIT_BUCKET_NAME")

if not ACCESS_TOKEN:
    raise ValueError("ZIPKIT_ACCESS_TOKEN environment variable not set")

API_URL = "https://zipkit.io/api/v1"
headers = {
    "Authorization": f"Bearer {ACCESS_TOKEN}",
    "Content-Type": "application/json"
}

data = {
    "urls": ["https://example.com/file.pdf"],
    "bucket_name": BUCKET_NAME or "default-bucket"
}

response = requests.post(f"{API_URL}/zips", json=data, headers=headers)
response.raise_for_status()

print("ZIP created:", response.json())
```

Set environment variables:

```bash
export ZIPKIT_ACCESS_TOKEN="your-access-token"
export ZIPKIT_BUCKET_NAME="my-bucket"
python your_script.py
```

## Batch Processing Multiple ZIPs

```python
import requests
import time
from concurrent.futures import ThreadPoolExecutor, as_completed

class ZipKitBatchProcessor:
    def __init__(self, access_token):
        self.client = ZipKitClient(access_token)

    def create_multiple_zips(self, zip_configs):
        """
        Create multiple ZIPs concurrently.

        Args:
            zip_configs: List of dicts with 'urls', 'bucket_name', 'key'

        Returns:
            List of created ZIP IDs
        """
        zip_ids = []

        with ThreadPoolExecutor(max_workers=5) as executor:
            futures = []

            for config in zip_configs:
                future = executor.submit(
                    self.client.create_zip,
                    config['urls'],
                    config['bucket_name'],
                    config.get('key')
                )
                futures.append(future)

            for future in as_completed(futures):
                try:
                    result = future.result()
                    zip_ids.append(result['id'])
                    print(f"Created ZIP: {result['id']}")
                except Exception as e:
                    print(f"Error creating ZIP: {e}")

        return zip_ids

# Usage
processor = ZipKitBatchProcessor("your-access-token")

configs = [
    {
        "urls": ["https://example.com/report1.pdf"],
        "bucket_name": "my-bucket",
        "key": "reports/report1.zip"
    },
    {
        "urls": ["https://example.com/report2.pdf"],
        "bucket_name": "my-bucket",
        "key": "reports/report2.zip"
    },
    {
        "urls": ["https://example.com/report3.pdf"],
        "bucket_name": "my-bucket",
        "key": "reports/report3.zip"
    }
]

zip_ids = processor.create_multiple_zips(configs)
print(f"Created {len(zip_ids)} ZIPs")
```

## Integration with Flask Webhook Handler

```python
from flask import Flask, request, jsonify
import requests

app = Flask(__name__)

# Your webhook secret
WEBHOOK_SECRET = "your-webhook-secret"

@app.route('/webhooks/zipkit', methods=['POST'])
def zipkit_webhook():
    """Handle ZipKit webhook notifications."""

    # Verify authorization
    auth_header = request.headers.get('Authorization')
    if auth_header != f'Bearer {WEBHOOK_SECRET}':
        return jsonify({'error': 'Unauthorized'}), 401

    # Parse webhook payload
    payload = request.json
    zip_id = payload['zip_id']
    status = payload['status']

    if status == 'succeeded':
        # ZIP is ready!
        bucket = payload['bucket']['name']
        key = payload['key']
        checksum = payload.get('checksum')

        print(f"ZIP {zip_id} completed successfully")
        print(f"Location: {bucket}/{key}")
        print(f"Checksum: {checksum}")

        # Process the ZIP (download, notify users, etc.)
        # process_completed_zip(bucket, key)

    elif status == 'failed':
        # ZIP failed
        print(f"ZIP {zip_id} failed")

        # Handle failure (notify user, retry, etc.)
        # handle_failed_zip(zip_id)

    return jsonify({'received': True}), 200

if __name__ == '__main__':
    app.run(port=5000)
```

## Tips and Best Practices

<AccordionGroup>
  <Accordion title="Use environment variables" icon="key">
    Never hardcode access tokens. Use environment variables or a secrets manager:

    ```python
    import os
    ACCESS_TOKEN = os.getenv("ZIPKIT_ACCESS_TOKEN")
    ```
  </Accordion>

  <Accordion title="Implement retry logic" icon="arrows-rotate">
    Add exponential backoff for transient errors:

    ```python
    from time import sleep

    def create_zip_with_retry(data, max_retries=3):
        for attempt in range(max_retries):
            try:
                response = requests.post(url, json=data, headers=headers)
                response.raise_for_status()
                return response.json()
            except requests.exceptions.RequestException as e:
                if attempt == max_retries - 1:
                    raise
                sleep(2 ** attempt)  # Exponential backoff
    ```
  </Accordion>

  <Accordion title="Use session for multiple requests" icon="bolt">
    Reuse connections for better performance:

    ```python
    with requests.Session() as session:
        session.headers.update(headers)
        response1 = session.post(url, json=data1)
        response2 = session.post(url, json=data2)
    ```
  </Accordion>

  <Accordion title="Set reasonable timeouts" icon="clock">
    Always set timeouts to prevent hanging:

    ```python
    response = requests.post(url, json=data, headers=headers, timeout=10)
    ```
  </Accordion>
</AccordionGroup>

## Next Steps

<CardGroup cols={2}>
  <Card title="JavaScript Examples" icon="js" href="/code-examples/javascript">
    See examples using Node.js and fetch
  </Card>

  <Card title="Ruby Examples" icon="gem" href="/code-examples/ruby">
    See examples using Ruby's Net::HTTP
  </Card>

  <Card title="cURL Examples" icon="terminal" href="/code-examples/curl">
    See examples using cURL
  </Card>

  <Card title="API Reference" icon="book" href="/api-reference/create-zip">
    View complete API documentation
  </Card>
</CardGroup>
